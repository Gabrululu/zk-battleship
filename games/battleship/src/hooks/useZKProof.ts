import { useState, useCallback } from 'react';
import type { Board } from '../utils/board';

export interface ProofResult {
  proof: Uint8Array;
  publicInputs: string[];
  isHit: boolean;
}

export interface ZKProofState {
  generating: boolean;
  error: string | null;
}

export function useZKProof() {
  const [state, setState] = useState<ZKProofState>({ generating: false, error: null });

  const generateProof = useCallback(
    async ({
      board,
      salt,
      boardHash,
      shotX,
      shotY,
    }: {
      board: Board;
      salt: string;
      boardHash: string;
      shotX: number;
      shotY: number;
    }): Promise<ProofResult> => {
      setState({ generating: true, error: null });

      try {
        const isHit = board[shotY][shotX] === 1;

        // Dynamically import heavy WASM modules only when needed
        const [{ Noir }, { UltraHonkBackend }] = await Promise.all([
          import('@noir-lang/noir_js'),
          import('@aztec/bb.js'),
        ]);

        // The compiled circuit artifact â€” generated by `nargo compile`
        // and copied to src/circuits/battleship.json
        const circuit = await import('../circuits/battleship.json');

        const noir = new Noir(circuit as never);
        const backend = new UltraHonkBackend((circuit as { bytecode: string }).bytecode);

        // Reshape flat board to [[u8;5];5] as Noir expects
        const boardMatrix = Array.from({ length: 5 }, (_, row) =>
          board[row].map(String),
        );

        const input = {
          board: boardMatrix,
          salt: salt,
          board_hash: boardHash,
          shot_x: String(shotX),
          shot_y: String(shotY),
          is_hit: isHit,
        };

        console.log('ZK inputs:', {
          boardMatrix,
          salt: salt.slice(0, 10) + '...',
          boardHash: boardHash.slice(0, 10) + '...',
          shotX,
          shotY,
          isHit,
        });

        const { witness } = await noir.execute(input as never);
        const rawResult = await backend.generateProof(witness);

        // bb.js version safety: proof may be Uint8Array directly or wrapped in { proof, publicInputs }
        const proofBytes: Uint8Array =
          rawResult instanceof Uint8Array ? rawResult
          : rawResult.proof instanceof Uint8Array ? rawResult.proof
          : new Uint8Array(Object.values(rawResult.proof as object) as number[]);

        const publicInputs: string[] = Array.isArray(rawResult.publicInputs)
          ? rawResult.publicInputs
          : [];

        console.log('ZK proof generated, bytes:', proofBytes.length);

        setState({ generating: false, error: null });
        return { proof: proofBytes, publicInputs, isHit };
      } catch (err) {
        const message = err instanceof Error ? err.message : String(err);
        setState({ generating: false, error: message });
        throw err;
      }
    },
    [],
  );

  return { generateProof, ...state };
}
